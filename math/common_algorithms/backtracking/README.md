# 回溯算法
  * 是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为**回溯法**，而满足回溯条件的某个状态的点称为**回溯点**。
----
在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。

若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。

而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。

## 基本步骤
  * 针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解；
  * 确定结点的扩展搜索规则；
  * 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

常用的剪枝函数：用约束函数在扩展结点处剪去不满足约束的子树；用限界函数剪去得不到最优解的子树。

## 算法实现
回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单。
```
void back_tracking(int i) {
    if (i < n) {
        for(j = 下界; j <= 上界; j++) { // 枚举i所有可能的路径
            if (meetFunc(i, j)) {      // 判断满足限界函数和约束条件
                back_tracking(i+1);    // 递归
                // 执行清理工作
            }
        }
    }
}
```

## 可用回溯法解决的常见问题
  * 八皇后问题
  * 01背包问题
  * 数独
  * 多数之和：给定一组候选集（C）和一个目标值T，在C的所有组合中，找出所有总和等于T的组合