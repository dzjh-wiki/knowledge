# 分治算法
  * 将一个复杂的问题分成两个或更多的相同或相似的子问题，再把细分子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

----
使用分治算法进行求解，也就意味着算法实现中，必会使用到**递归**。  

## 适用情况
分治法所能解决的问题一般具有以下几个特征：  
  * 问题的规模 缩小 到一定的程度 就可以容易地解决；
  * 问题可以分解为若干个规模较小的相同问题，即该问题 具有最优子结构性质；
  * 利用该问题分解出的子问题的解，可以合并为该问题的解；
  * 该问题所分解出的各个子问题是相互独立的，即**子问题之间不包含公共的子子问题**。

第1个特征随着问题规模的减少，问题自然会容易解决。特征2，3是分治的前提。即Divide-and-Conquer的必要条件。 
第4个特征，对于存在公共子问题的问题，使用分治算法会存在重复计算的问题，使用动态规划较为合适。

## 分治法的基本步骤
分治法在每一层递归上都有三个步骤：
  * 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；
  * 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题；
  * 合并：将各个子问题的解合并为原问题的解。

```
Divide-and-Conquer(P)

    if |P|≤n0 // n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解

    then return(ADHOC(P))  // ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P

    // 将P分解为较小的子问题 P1 ,P2 ,...,Pk
    for i←1 to k

    do yi ← Divide-and-Conquer(Pi) // 递归解决Pi

    T ← MERGE(y1,y2,...,yk) // 合并子问题

    return(T)
```

## 分治法的复杂性分析
在解决规模为n的分治问题时，总是先递归地求解a个规模为n/b的子问题。
假设合并子问题的解为原问题的解需用f(n)个单位时间，则分治法的时间复杂度为：
$$T(n) = aT(\frac{n}{b}) + f(n)$$

## 可用分治法解决的常见问题
  * 二分搜索
  * 大整数乘法
  * Strassen矩阵乘法
  * 棋盘覆盖
  * 合并排序
  * 快速排序
  * 线性时间选择
  * 最接近点对问题
  * 循环赛日程表
  * 汉诺塔