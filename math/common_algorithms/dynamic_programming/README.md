# 动态规划
  * 每次决策依赖于当前状态，又随即引起状态的转移。
  * 一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。

----
简单来讲，动态规划算法的核心是**状态**，即**已求出的（过程）解**。

## 与分治法的异同之处
**同：**
将待求解的问题分解为若干个子问题（阶段）进行求解。

**异：**
适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。

## 动态规划流程
将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段或前一子问题的解，为后一子问题的求解提供了有用的信息。
在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。
依次解决各子问题，最后一个子问题就是初始问题的解。

由于动态规划解决的问题大部分有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。

## 适用情况
使用动态规划来求解的问题一般需具有3个性质：
  * 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
  * 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。
  * 有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（**该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势**）

## 动态规划求解步骤
**划分阶段**
按照问题的时间或空间特征，把问题分为若干个阶段。
在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。

**确定状态和状态变量**
将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。
注意，状态的选择要满足无后效性。

**确定决策并写出状态转移方程**
因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。
但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。

**寻找边界条件**
给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。


一般，只要解决问题的**阶段、状态和状态转移决策**确定了，就可以写出**状态转移方程（包括边界条件）**。  

实际应用中可以按以下几个简化的步骤进行设计：
  * （1）分析最优解的性质，并刻画其结构特征。
  * （2）递归的定义最优解。
  * （3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值
  * （4）根据计算最优值时得到的信息，构造问题的最优解

## 动态规划与递归的关系
使用动态规划求解问题，最重要的就是确定动态规划三要素：
  * （1）问题的阶段
  * （2）每个阶段的状态
  * （3）从前一个阶段转化到后一个阶段之间的递推关系。

其中，递推关系必须是从次小的问题开始到较大的问题之间的转化。
也就意味着，动态规划往往可以用递归程序来实现，不过**因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处**。  

整个求解过程就可以用**一个最优决策表**来描述，**最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系**，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。

## 动态规划求解的常用套路
对于一个问题，可以根据**递归的暴力解法 -> 带备忘录的递归解法 -> 非递归的动态规划解法**的流程套路，进行求解。

### 递归的暴力解法
一般可使用动态规划来求解的问题，都可使用递归来暴力穷举进行求解。

### 带备忘录的递归解法
一般动态规划问题，大多有重叠子问题，因此可以在递归中，通过备忘录（字典）来记录每个子问题的答案，从而避免重复计算。

### 非递归的动态规划解法
将以上的备忘录独立出来，也就是说，通过非递归的循环方式一步步生成备忘录，每次循环都可使用备忘录已有的数据，从而避免使用了递归。


## 实例
Leetcode上的算法题。

题解分析：
```csharp
// 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

// '.' 匹配任意单个字符
// '*' 匹配零个或多个前面的那一个元素
// 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

// 说明:

// s 可能为空，且只包含从 a-z 的小写字母。
// p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。


// 需要注意的是：&&的优先级比||要高！！！

public bool IsMatch(string s, string p) {
    bool[,] dp = new bool[s.Length + 1, p.Length + 1]; // 备忘录
    dp[s.Length, p.Length] = true; // 
    for(int i=s.Length;i>=0;i--)
    {
        for(int j=p.Length-1;j>=0;j--)
        {
            bool firstmatch = i < s.Length && (p[j] == s[i] || p[j] == '.');
            if(j+1<p.Length&&p[j+1]=='*')
            { // 当下一个匹配串字符是*时，若当前字符i跟下两个匹配串字符匹配，则当前位置必定匹配；若当前字符匹配，则需判断上一个字符与当前匹配串字符是否匹配（其实dp[i + 1,j]已经包含了dp[i + 1,j+2]的匹配状态信息了，故而不需载另外判断dp[i + 1,j+2]）。
              dp[i, j] = dp[i, j + 2] || firstmatch && dp[i + 1,j];
            }else
            {
              // 若当前字符匹配，还需判断上个字符是否跟上一个匹配串匹配。
              dp[i, j] = firstmatch && dp[i + 1, j + 1];
            }
        }
    }
    return dp[0, 0];
}
```